#include <iostream>
#include <cstdio>
using namespace std;
/*
本题采用贪心算法，主要需要解决 2*2 规格的盒子如何放置
先从大到小进行考虑，由于 6*6 5*5 4*4 都需要新箱子，同时每 4 个 3*3 箱子需要新箱子
此时考虑将 2*2 和 1*1 的箱子放置在之前箱子的空隙中，若不足，再开新箱子

1 个 6*6 箱子无法放置其他产品
1 个 5*5 箱子可以放置 11 个 1*1 的箱子
1 个 4*4 箱子可以放置 5 个 2*2 箱子或 20 个 1*1 箱子
1 个 3*3 箱子可以放置 5 个 2*2 箱子和 7 个 1*1 箱子
2 个 3*3 箱子可以放置 3 个 2*2 箱子和 6 个 1*1 箱子
3 个 3*3 箱子可以放置 1 个 2*2 箱子和 5 个 1*1 箱子
4 个 3*3 箱子无法放置其他箱子
对于 2*2 箱子，可以放置 9 个
对于 1*1 箱子，可以放置 36 个
*/
// 用于记录输入的大小箱子个数
int a[6];
// 记录不同 3*3 箱子对应的 2*2 箱子可放置数目
int counts4[4] = {0, 5, 3, 1};
// 当前可以放置 1*1 和 2*2 箱子的数目
int c1, c2;

int main()
{
    // 输入
    while (scanf("%d %d %d %d %d %d", &a[0], &a[1], &a[2], &a[3], &a[4], &a[5]))
    {
        // 当都为 0 时，跳出
        if (a[0] == 0 && a[1] == 0 && a[2] == 0 && a[3] == 0 && a[4] == 0 && a[5] == 0)
        {
            break;
        }

        // 最少的箱子数目
        int counts = 0;
        // 对于 6*6 5*5 4*4 都需要新箱子，对于 3*3 需要多情况考虑，但取整即可
        counts = a[5] + a[4] + a[3] + (a[2] + 3) / 4;
        // 考虑在已有箱子的情况下，能够放置 2*2 箱子的数目
        c2 = 5 * a[3] + counts4[a[2] % 4];
        // 当输入的量大于可装数目时，需要开新箱子，新箱子数目也向下取整即可
        if (a[1] > c2)
        {
            counts += (a[1] - c2 + 8) / 9;
        }

        // 现有箱子情况下，仍能放置 1*1 箱子的数目
        c1 = counts * 36 - a[5] * 36 - a[4] * 25 - a[3] * 16 - a[2] * 9 - a[1] * 4;
        // 当输入的数目大于能放置的箱子数目时
        if (a[0] > c1)
        {
            // 对于新箱子数目，向下取整即可， 36 个以内取单个即可，大于 36 个时，需要开新箱子
            counts += (a[0] - c1 + 35) / 36;
        }

        // 输出
        printf("%d\n", counts);

    }

    return 0;
}
