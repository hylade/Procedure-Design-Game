#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
/*
算法一：在可选的工作中（就是和当前已选的工作都不重叠的工作）中，每次都选取开始时间最早的工作
算法二：在可选的工作中，每次都选取结束时间最早的工作：正确
算法三：在可选的工作中，每次都选取用时最短的工作
算法四：在可选的工作重，每次都选取与最少可选工作有重叠的工作

算法证明：
算法二的思路：
将所有区间按右端点坐标从小到大排序，顺序处理每个区间。如果它与当前已选的所有区间都没有重叠，则选择该区间，否则不选

证明1（归纳法）：
显然，该算法最后选出的区间不互相重叠，下面证明所选出区间的数量是最多的。
设 fi 为该算法所接受的第 i 个区间的右端点坐标， gi 为某最优解中的第 i 个区间的右端点坐标

1）当 i >= 1 时，该算法所接受的第 i 个区间的右端点坐标 fi <= 某最优解中的第 i 个区间的右端点坐标 gi

对于 i = 1 ，命题显然为真，因为算法第 1 个选择的区间拥有最小右端点坐标。令 i > 1 ，假定论断对 i - 1 为真，即 fi - 1 <= gi - 1
则最优解的第 i 个可选区间所组成的集合包含于执行该算法时第 i 个可选区间所组成的集合；
而当算法选择第 i 个区间时，选的是在可选区间中右端点坐标最小的一个，所以有 fi <= gi。证毕。

2）最优解选出的区间数量 m = 该算法选出的区间数量 k

设该算法选出了 k 个区间，而最优解选出了 m 个区间
假设 m > k ，根据命题 1) ，有 fk <= gk 。由于 m > k ，必然存在某区间，在 gk 之后开始，故也在 fk 之后开始。
而该算法一定不会在选了第 k 个区间后停止，还会选择更多的区间，产生矛盾。所以 m <= k ,又因为m是最优解选出区间个数，所以 m = k 。
综上所述，算法选出的区间是最优解。

证明2：
对于现有区间 x ，其右端点是最小的，对于其他区间组合有两种，一种是与其相交的区间组合 A ，另一组是与其不相交的区间组合 B
当取 B 时，对 x 没有影响，主要要考虑 A 中区间能否替换区间 x ，但对于 A 中区间 y ，与 x 相交的同时，也与 A 中其他区间相交
此时区间数量对于 x 和 y 没有区别，但是 y 区间还可能与 B 中的区间相交，此时将比 x 差，故应选择 x ，然后在 B 中选择右端点最小的情况
再如上方法思考

证明3（挑战程序设计竞赛思路）：
直观解释：结束时间越早之后可选的工作越多
严格证明：与其他选择方案相比，该算法的选择方法在选取了相同数量的更早开始的工作时，其最终结束时间不会比其他方案的更晚，所以不存在选取更多工作的选择方案
*/

const int MAX_N = 100000;
int n, s[100000], t[100000];
// 用于对工作排序的 pair 数组
pair<int, int> p[MAX_N];
int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &s[i]); // 输入起点数组
    }
    for (int j = 0; j < n; j++)
    {
        scanf("%d", &t[j]); // 输入终点数组
    }
    for (int i = 0; i < n; i++) // 为了使用结束时间进行排序，将 t 放入 first 中， 将 s 放入 second 中
    {
        p[i].first = t[i];
        p[i].second = s[i];
    }
    sort(p, p + n);
    int t = 0, ans = 0; // t 作为当前最后一个区间的右端点
    for (int i = 0; i < n; i++)
    {
        if (t < p[i].second) // 确定不相交
        {
            ans += 1;
            t = p[i].first;
        }
    }
    printf("%d", ans);



    return 0;
}
