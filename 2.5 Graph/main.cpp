#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
/*
图由顶点和边组成，顶点表示对象，边表示两个对象的连接关系
顶点的集合是 V ， 边的集合是 E 的图记为 G=(V, E) ,连接两点 u 和 v 的边用 e=(u,v) 表示
图可以分为没有指向性的无向图和具有指向性的有向图
边上带权值的称为带权图
*/

/*
无向图的术语
若两个顶点之间有边连接，那么就视为两个顶点相邻，相邻顶点的序列称为路径
起点和终点重合的路径称为圈
任意两点之间都有路径连接的图称为连通图
顶点连接的边数称为该顶点的度
没有圈的连通图称为数，没有圈的非连通图称为森林

一棵树的边数恰好为顶点数 -1 ，反之，若边数等于顶点数 -1 的连通图就是一棵树
*/

/*
有向图的术语
以有向图的顶点 v 为起点的边的集合称为出度
以顶点 v 为重点的边的集合称为入度

没有圈的有向图称为 DAG
对于每个顶点都给定一个编号，第 i 号顶点称为 vi ，那么存在顶点 vi 到顶点 vj 的边时就有 i < j 成立，
这样的编号方式为拓扑序
*/

/*
图的表示方法可以分为邻接矩阵和邻接表
邻接矩阵用 |V|*|V| 的二维数组来表示图， g[i][j]  表示顶点 i 和顶点 j 之间的关系
对于无向图，若存在边连接，便设为 1 ，否则为 0
对于有向图，若从 i 指向 j 有边， g[i][j] 便设为 1 ，否则为 0
对于带权图，表示的是从 i 到 j 的权值，一般边不存在时，需要取 inf


使用邻接矩阵是，需要花费 O(|V|^2) 的存贮空间，对于边少的稀疏图，空间浪费严重
且对于两点重边或者顶点自环情况，能够表示无向图，但无法表示带权图

必须保存所有边时，可以使用邻接表
邻接表将连接信息保存在链表中，一般只需要 O(|V| + |E|) 中
如
3 3 (顶点数 边数)
0 1 (有一条 0 到 1 的边)
0 2 (有一条 0 到 2 的边)
1 2 (有一条 1 到 2 的边)
*/
// 样例 1
vector<int> G[100];
/*
边上有属性的情况
struct edge{int to, cost};
vector<edge> G[100];
*/
int main()
{
    int V, E;
    scanf("%d %d", &V, &E);
    for (int i = 0; i < E; i++)
    {
        // 从 s 向 t 连边
        int s, t;
        scanf("%d %d", &s, &t);
        G[s].push_back(t); // 该函数将一个新的元素加到 vector 的最后面，位置为当前最后一个元素的下一个元素
        // 若是无向图，则需要再从 t 向 s 连边
    }
    /*
    图的操作
    */

    return 0;
}

// 样例 2
/*
struct vertex {
    vector<vertex*> edge;
    // 顶点属性
};

vertex G[100];

int main(){
    int V, E;
    scanf("%d %d", &V, &E);
    for (int i = 0; i < E; i++)
    {
        int s, t;
        scanf("%d %d", &s, &t);
        G[s].edge.push_back(&G[t]);
        //G[t].edge.push_back(&G[s]);
    }
    // 图的操作
    return 0;
}
*/
