#include <iostream>
#include <math.h>
#include <string.h>
#include <algorithm>
#include <cstdio>
using namespace std;
/*
对于版本 -1 ，使用双重循环的方法进行搜索，但是复杂度为 O(n^2)
此处采用贪心 + 二分的方法，复杂度为 O(nlogn)
a[i] 表示第 i 个数据
dp[i] 用来表示长度为 i+1 的 LIS 结尾元素的最小值
根据贪心算法的思想，对于一个上升子序列，当然最后一个元素越小越有利于添加新的元素，这样 LIS 长度自然可以更长
那么，我们需要维护 dp 数组，其表示的便是长度为 i + 1 的 LIS 结尾元素的最小值，保证每一位都是最小值

同样对于序列 a(1, 7, 3, 5, 9, 4, 8)，dp 的变化过程如下：
dp[0] = a[0] = 1，长度为 1 的 LIS 结尾元素的最小值自然没得挑，就是第一个数（dp = {1}）
对于a[1] = 7， a[1] > dp[0]，因此直接添加到 dp 尾，dp[1] = a[1]（dp = {1, 7}）
对于a[2] = 3，dp[0] < a[2] < dp[1]，因此 a[2] 替换 dp[1] ，令 dp[1] = a[2]，因为长度为 2 的 LIS ，
结尾元素自然是 3 好过于 7 ，因为越小这样有利于后续添加新元素（dp = {1, 3}）
对于a[3] = 5，a[3] > dp[1]，因此直接添加到 dp 尾，dp[2] = a[3]（dp = {1, 3, 5}）
对于a[4] = 9，a[4] > dp[2]，因此同样直接添加到 dp 尾，dp[3]=a[9]。 （dp = {1, 3, 5, 9}）
对于a[5] = 4，dp[1] < a[5] < dp[2]，因此 a[5] 替换值为 5 的 dp[2] ，因此长度为 3 的 LIS，
结尾元素为 4 会比 5 好（dp = {1, 3, 4, 9}）
对于a[6] = 8，dp[2] < a[6] < dp[3]，同理 a[6] 替换值为 9 的 dp[3] ，道理你懂（dp = {1, 3, 5, 8}）

通过上述求解，可以发现 dp 数组是单调递增的，因此对于每一个 a[i] ，先判断是否可以直接插入到 dp 数组尾部，
即比较其与 dp 数组的最大值即最后一位；如果不可以，则找出 dp 中第一个大于等于 a[i] 的位置，用 a[i] 替换之。
这个过程可以利用二分查找，因此查找时间复杂度为 O(logN) ，所以总的时间复杂度为 O(NlogN)
*/
int T, N;
int a[40001]; // 表示数据
int dp[40001]; // 表示长度为 i+1 的 LIS 结尾元素的最小值
#define inf 0x7f7f7f7f

int main()
{
    // 运行次数
    scanf("%d", &T);
    while (T--)
    {
        // 本次运行数组长度
        scanf("%d", &N);
        for (int i = 0; i < N; i++)
        {
            scanf("%d", &a[i]);
            // 初始化为无限大
            dp[i] = inf;
        }
        // 记录 dp 当前最后一位的下标
        int pos = 0;
        // dp[0] 显然为 a[0]
        dp[0] = a[0];
        for (int i = 1; i < N; i++)
        {
            // 若 a[i] 大于 dp 数组的最大值，直接添加
            if (a[i] > dp[pos])
            {
                dp[pos++] = a[i];
            }
            // 否则找到 dp 中第一个大于等于 a[i] 的位置，用 a[i] 替换
            else
            {
                // lower_bound 是用二分查找原理
                dp[lower_bound(dp, dp + pos + 1, a[i]) - dp] = a[i];
            }
        }
        printf("%d", pos);

    }

    return 0;
}
