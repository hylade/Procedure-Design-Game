#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

/*
宽度优先搜索（BFS, Breadth-First Search）是一种搜索手段，与深度优先搜索类似，从某个状态出发搜索所有可以达到的状态
与 DFS 不同的是搜索的顺序，宽度优先搜索总是先搜索距离初始状态近的状态。
也就是说，它是按照开始状态-只需 1 次转移就可以到达的所有状态-只需 2 次转移就可以到达的所有状态...
对于同一个状态，宽度优先搜索只经过一次，因此复杂度为 O(状态数*转移的方式)

深度优先搜索其实是利用了栈进行计算（后入先出），而宽度优先搜索则使用了队列（先进先出）
搜索时首先将初始状态添加到队列里，此后从队列的最前端不断取出状态，把从状态可以转移的状态中尚未访问的状态加入队列，
如此往复，直到队列被取空或找到解

其实，就是按照初始距离由近及远的顺序遍历：从上到下，从左到右
*/
const int INF = 100000000;
// 使用 pair 表示状态时，使用 typedef 进行定义更加方便
typedef pair<int, int> P;
int sx, sy; // 起点坐标
int gx, gy; // 终点坐标
int n, m;
char field[100][100]; // 迷宫字符串

/*
本题中，状态仅为目前所在位置的坐标，因此可以构造成 pair 或者编码成 int 来表达状态
若状态复杂时，需要封装成类来表示
转移的方向由于为四方向移动，状态数与迷宫的大小相等，所以复杂度是 O(4 * N * M) = O(N* M)

由于本题在运行过程中，可以获得到各个位置的最短距离，可用 d[N][M] 数组将最短距离保存起来，同时初始时，用大常数 INF 来初始，但需要注意溢出情况
*/

int d[100][100];
// 四个方向的移动向量
int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};

int bfs()
{
    queue<P> que;
    for (int a = 0; a < n; a++)
    {
        for (int b = 0; b < m; b++)
        {
            // 将所有位置都初始化为 INF
            d[a][b] = INF;
        }
    }

    // 将起点加入队列
    que.push(P(sx, sy));
    // 将起点最短距离设为 0
    d[sx][sy] = 0;

    // 循环直到队列 que 长度为 0
    while (que.size())
    {
        // 从队列最前端取出元素 P
        P p = que.front();
        que.pop();
        // 若取出的值为终点位置，则结束搜索
        if (p.first == gx && p.second == gy)
        {
            break;
        }
        for (int i = 0; i < 4; i++)
        {
            // 移动后位置 nx， ny
            int nx = p.first + dx[i], ny = p.second + dy[i];
        // 判断是否可以移动且是否已经访问过，若 d[nx][ny] != INF ，则已经访问过
            if (0 <= nx && nx <= n && 0 <= ny && ny <= m && field[nx][ny] != '#' && d[nx][ny] == INF)
            {
                // 若可以移动（非墙壁）的情况，则将其加入队列，同时到该位置的距离增加 1
                que.push(P(nx, ny));
                d[nx][ny] = d[p.first][p.second] + 1;
            }
        }
    }
    return d[gx][gy];
}
int main()
{
    scanf("%d %d", &n, &m);
    for (int k = 0; k < n; k++)
    {
        scanf("%s", field[k]); // 迷宫
    }
    sx = 0, sy = 1, gx = 9, gy = 8;
    int time = bfs();
    printf("%d", time);

    return 0;
}

/*
总结：
宽度优先搜索与深度优先搜索一样，都会遍历所有的状态，但是递归函数编写较为简短，大多数情况推荐使用深度优先搜索
但在求最短路时深度优先搜索需要反复经过同样的状态，此时应使用宽度优先搜索

宽度优先搜索会把状态直接加入队列，通常需要与状态数成正比的内存空间，反之，深度优先搜索是与最大的递归深度成正比
一般与状态数相比，递归深度不会太大，所以可认为深度优先搜索较节省内存
*/
