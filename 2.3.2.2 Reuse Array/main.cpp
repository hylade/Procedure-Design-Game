#include <iostream>
#include <cstdio>
using namespace std;
/*
对于 01 背包问题和完全背包问题可以重复利用一个数组来实现
并且两者程序相差不大，差异只有循环的方向
重复利用数组虽然可以节省内存空间，但若使用不当，也会产生很多 bug
*/
// 01 背包
int n, W;
int w[100], v[100];
int dp[101];

int main()
{
    scanf("%d %d", &n, &W);
    for (int i = 0; i < n; i++)
    {
        scanf("%d %d", &w[i], &v[i]);
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = W; j >= w[i]; j--)
        {
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
        }
    }
    printf("%d", dp[W]);


    return 0;
}

// 完全背包
/*
int main()
{
    scanf("%d %d", &n, &W);
    for (int i = 0; i < n; i++)
    {
        scanf("%d %d", &w[i], &v[i]);
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = w[i]; j <= W; j++) // 因为在第 i 个阶段，若 j 小于第 i 个物品质量，肯定放不进去，不必验算
        {
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
        }
    }
    printf("%d", dp[W]);


    return 0;
}
*/

/*
为什么将循环次序更改就能将 01 背包和完全背包进行调换
解释1：因为在 01 背包中按照逆序循环是为了保证第 i 此循环中的状态 f[i][j] 是由状态
f[i - 1][j - w[i]] 递推而来的，换言之，就是为了保证每件物品只选一次，保证在
考虑“选入第 i 件物品”的策略时，依据的是一个绝无已经选入第 i 件物品的子结果

解释2：F[i, j] = max{F[i − 1, j],F[i − 1, j − w[i]] + v[i]}
可见计算 F[i, j] 时，是从阶段 i - 1 阶段的两个状态转移过来的，一个是如果不放
第 i 个物体时，则前 i - 1 个物体在背包中重量为 j 的最大价值，一个是如果放入第 i
个物体时，在背包为 j - w[i] 的最大价值再加上 v[i] ，较大值变为结果
若用一维数组来进行表示时，则在每个阶段时 F[j] 如果是左值，则表示当前阶段的，即为
F[i, j] ，如果是右值，需要分为两种情况，如果已经被更新（重新赋值）过则表示当前阶段的，
若没有被覆盖过，则表示上一阶段，即 F[i - 1, j]
因为在计算 F[i, j] 时，用到的是 F[i - 1, j - w[i]] ，要想在这时用到一维数组
F[j - w[i]] 取到该值，则需要保证它没有被更新过，即它暂时没有被计算，所以要进行逆序计算

解释1：而完全背包的特点恰好是每种物品可以选择无限件，所以在考虑"加选一种 i 物品"的策略
时，却需要一个可能已选入第 i 种物品的子结果 f[i][j - w[i]] ，所以为正循环

解释2：状态转移方程为 F[i, j] = max{F[i − 1, j],F[i, j − w[i]] + v[i]}
表示如果不放第 i 个物品则沿用上一阶段的 F[j] ，若使用，则需要从这一阶段的 j - w[i]
中累加，这也侧面解释了 P59 的变形公式
若用一维数组进行表示， F[j] 在左值时，表示这一阶段的，要保证右值 F[j] 是上一阶段的，
同时 F[j - w[i]] 是这一阶段的，所以需要顺序计算
*/
